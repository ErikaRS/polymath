<!DOCTYPE html>
<h1>Polymath Endpoint</h1>
<p>
  This is a <a href="https://github.com/dglazkov/polymath">polymath</a> endpoint.
</p>
<div id="surface"></div>
<p>
  See more about how to get started at <a
    href="https://github.com/dglazkov/polymath#readme">https://github.com/dglazkov/polymath</a>
</p>
{% if restricted_message %}
<p>This server has additional private content that requires an access token to access. {{ restricted_message }}</p>
{% endif %}
<template id="query-view">
  <p>
    <label>Query:
      <input type="text" id="query">
    </label>
    <button id="ask">Ask</button>
  </p>
  <details>
    <summary>More options</summary>
    <p>
      <label for="access_token">access_token (optional):</label>
      <input type="text" name="access_token" id="access_token">
    </p>
    <p>
      <button id="clear">Clear Key and Access Token</button>
    </p>
  </details>
</template>
<template id="request-key-view">
  <p>
    <label>
      To query this server, enter your Open AI API key:
      <input name="key" type="text">
    </label>
    <button>Save Key</button>
  </p>
  <p>
    <em>Your Open AI API key is stored locally and only ever transmitted directly to openai.com</em>
  </p>
</template>
<template id="loading-view">
  <p>Loading...</p>
</template>
<template id="results-view">
  <h3>Results</h3>
  <div id="completion"></div>
  <h3>Sources</h3>
  <ul id="sources">
  </ul>
</template>
<template id="error-view">
  <h3>Error</h3>
  <div id="message"></div>
</template>

<script type="module">

  class Keystore {
    get openai_api_key() {
      return localStorage.getItem('openai_api_key');
    }

    set openai_api_key(value) {
      localStorage.setItem('openai_api_key', value);
    }

    get access_token() {
      return localStorage.getItem('access_token');
    }

    set access_token(value) {
      localStorage.setItem('access_token', value);
    }

    clear() {
      localStorage.removeItem('openai_api_key');
      localStorage.removeItem('access_key');
    }
  }

  class Polymath {
    async ask(query) {
      const form = new FormData();
      form.append('version', '0');
      form.append('query_embedding_model', 'openai.com:text-embedding-ada-002');
      form.append('sort', 'similarity');
      for (const [key, value] of Object.entries(query)) {
        form.append(key, value);
      }
      const url = new URL(window.location);
      const result = await (await fetch(url, {
        method: 'POST',
        body: form
      })).json();
      return result;
    }

    static encode_embedding(data) {
      return btoa(String.fromCharCode(...(new Uint8Array(new Float32Array(data).buffer))));
    }

    static create_prompt({ query, results }) {
      const context = Object.values(results.content).map(chunk => chunk.text).join('\n');
      return `Answer the question as truthfully as possible using the provided context, and if the answer is not contained within the text below, say \"I don't know.\"\n\nContext:\n${context} \n\nQuestion:\n${query}\n\nAnswer:`;
    }

    static async synthesizeAnswers({ key, query, access_token }) {
      const server = new Polymath();
      const openai = new OpenAI(key);
      const result = {
        error: null,
        infos: null,
        completion: null,
      }

      const embedding = await openai.embedding(query);
      if (embedding.error) {
        result.error = embedding.error;
        return result;
      }

      const query_embedding = Polymath.encode_embedding(embedding.result);
      access_token = access_token || ''
      const polymath_results = await server.ask({ query_embedding, access_token });
      if (polymath_results.error) {
        result.error = polymath_results.error;
        return result;
      }

      const context = Polymath.create_prompt({
        query: query,
        results: polymath_results,
      });
      const completion_result = await openai.completion(context);
      if (completion_result.error) {
        result.error = completion_result.error;
        return result;
      }
      result.infos = Object.values(polymath_results.content).map(entry => entry.info);
      result.completion = completion_result.result;
      return result;
    }
  }

  class OpenAI {
    constructor(key) {
      this._key = key;
    }

    async _call_api(type, payload, getter) {
      const url = `https://api.openai.com/v1/${type}`;
      const result = await (await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this._key}`,
        },
        body: JSON.stringify(payload)
      })).json();
      if (result.error)
        return {
          error: result.error.message
        }
      return {
        result: getter(result)
      };
    }

    async validate() {
      const url = `https://api.openai.com/v1/models`;
      const result = await (await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${this._key}`,
        }
      })).json();
      return !result.error;
    }

    async completion(prompt) {
      return await this._call_api('completions', {
        model: 'text-davinci-003',
        prompt: prompt,
        max_tokens: 1024,
        temperature: 0,
        top_p: 1,
        n: 1,
        stream: false,
        logprobs: null,
        stop: '\n'
      }, out => out.choices[0].text);
    }

    async embedding(query) {
      return await this._call_api('embeddings', {
        input: query,
        model: 'text-embedding-ada-002'
      }, out => out.data[0].embedding);
    }
  }

  const viewLogic = {
    'request-key': (view, controller) => {
      const button = view.querySelector('button');
      const input = view.querySelector('input');
      button.addEventListener('click', () => controller.storeKey(input.value));
    },
    'query': (view, controller, query_value) => {
      const query = view.querySelector('#query');
      query.value = query_value;
      const access_token = view.querySelector('#access_token');
      view.querySelector('#ask').addEventListener('click',
        () => controller.askServer({
          query: query.value,
          access_token: access_token.value,
        }));
      view.querySelector('#clear').addEventListener('click',
        () => controller.clearKeys());
    },
    'results': (view, completion, infos) => {
      view.querySelector('#completion').textContent = completion;
      view.querySelector('#sources').innerHTML = infos.map(info => `<li><a href="${info.url}">${info.title}</a></li>`).join('\n');
    },
    'error': (view, error) => {
      const message = view.querySelector('#message');
      message.textContent = error;
    }
  }

  class Views {
    constructor() {
      this._surface = document.querySelector('#surface');
    }

    hide(viewId) {
      const instance = document.getElementById(`${viewId}-view-instance`);
      if (instance)
        instance.hidden = true;
    }

    show(viewId, ...data) {
      const templateId = `${viewId}-view`;
      const template = document.getElementById(templateId);
      const clone = template.content.cloneNode(true);
      const logic = viewLogic[viewId];
      logic && logic(clone, ...data);
      const instance = document.createElement('div');
      instance.appendChild(clone);
      instance.id = `${templateId}-instance`;
      this._surface.appendChild(instance);
    }

    clear() {
      this._surface.textContent = '';
    }
  }

  class Controller {
    constructor() {
      this.store = new Keystore();
      this.views = new Views();
      this.results = null;
      this.url = new URL(window.location);
    }

    async storeKey(key) {
      const openai = new OpenAI(key);
      if (!await openai.validate()) {
        this.results = {
          error: 'Invalid API key'
        };
        this.start();
        return;
      }
      this.store.openai_api_key = key;
      this.results = null;
      this.start();
    }

    askServer({ query, access_token }) {
      this.url.searchParams.set('query', query);
      if (access_token)
        this.store.access_token = access_token;
      window.location.assign(this.url);
    }

    clearKeys() {
      this.store.clear();
      this.start();
    }

    async start() {
      this.views.clear();
      if (!this.store.openai_api_key) {
        this.views.show('request-key', this);
      } else {
        const query = this.url.searchParams.get('query');
        this.views.show('query', this, query);
        if (query) {
          this.views.show('loading', this);
          const answers = await Polymath.synthesizeAnswers({
            query: query,
            key: this.store.openai_api_key,
            access_token: this.store.access_token,
          });
          this.views.hide('loading')
          if (answers.error) {
            this.views.show('error', this, answers.error);
          } else {
            this.views.show('results', answers.completion, answers.infos);
          }
        }
      }
      if (this.results && this.results.error) {
        this.views.show('error', this.results.error);
      }
    }
  }

  const controller = new Controller();
  controller.start();
</script>