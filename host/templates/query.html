<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>A Polymath Client</title>
<link rel="stylesheet" href="static/mvp.css" />
<link rel="apple-touch-icon" sizes="180x180" href="static/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="static/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="static/favicon-16x16.png">
<link rel="shortcut icon" href="static/favicon.ico">
<link rel="manifest" href="static/site.webmanifest">
<header>
  <h1>A Polymath Client</h1>
  <p>
    This is a <a href="https://github.com/dglazkov/polymath">polymath</a> endpoint.
  </p>
</header>
<main id="surface"></main>
<footer>
  {% if restricted_message %}
  <p>This server has additional private content that requires an access token to access. {{ restricted_message }}</p>
  {% endif %}
  <p>
    See more about how to get started at <a
      href="https://github.com/dglazkov/polymath#readme">https://github.com/dglazkov/polymath</a>
  </p>
</footer>
<template id="query-view">
  <p>
    <label>Query:
      <input type="text" id="query" placeholder="Enter your question here">
    </label>
    <button id="ask">Ask</button>
  </p>
  <details>
    <summary>More options</summary>
    <p>
      <label for="access_token">access_token (optional):</label>
      <input type="text" name="access_token" id="access_token">
    </p>
    <p>
      <button id="clear">Clear Key and Access Token</button>
    </p>
  </details>
  <script arguments="controller,query_value">
    const textInput = this.querySelector('#query');
    textInput.value = query_value;
    const access_token = this.querySelector('#access_token');
    const askButton = this.querySelector('#ask');
    const askServer = () => controller.askServer({
      query: textInput.value,
      access_token: access_token.value,
    });
    if (!query_value) {
      askButton.disabled = true;
    }
    textInput.addEventListener('keyup', (event) => {
      askButton.disabled = textInput.value.length < 3;
      if (event.keyCode != 13 || askButton.disabled) {
        return;
      }
      askServer();
    });
    askButton.addEventListener('click', askServer);
    this.querySelector('#clear').addEventListener('click',
      () => controller.clearKeys());
  </script>
</template>
<template id="request-key-view">
  <p>
    <label>
      To query this server, enter your Open AI API key:
      <input name="key" type="text">
    </label>
    <button>Save Key</button>
  </p>
  <p>
    <em>Your Open AI API key is stored locally and only ever transmitted directly to openai.com</em>
  </p>
  <script arguments="controller">
    const button = this.querySelector('button');
    const input = this.querySelector('input');
    button.addEventListener('click', () => controller.storeKey(input.value));
  </script>
</template>
<template id="loading-view">
  <p>Loading...</p>
</template>
<template id="results-view">
  <h3>Results</h3>
  <div id="completion"></div>
  <h3>Sources</h3>
  <ul id="sources">
  </ul>
  <script arguments="completion,infos">
    function removeDuplicates(arr) {
      let seen = new Set();
      return arr.filter(item => {
        if (!seen.has(item.url)) {
          seen.add(item.url);
          return true;
        }
        return false;
      });
    }

    this.querySelector('#completion').textContent = completion;
    this.querySelector('#sources').innerHTML = removeDuplicates(infos).map(info => `<li><a href="${info.url}">${info.title || info.url}</a></li>`).join('\n');
  </script>
</template>
<template id="error-view">
  <h3>Error</h3>
  <div id="message"></div>
  <script arguments="error">
    const message = this.querySelector('#message');
    message.textContent = error;
  </script>
</template>

<script type="module">

  class Keystore {
    get openai_api_key() {
      return localStorage.getItem('openai_api_key');
    }

    set openai_api_key(value) {
      localStorage.setItem('openai_api_key', value);
    }

    get access_token() {
      return localStorage.getItem('access_token');
    }

    set access_token(value) {
      localStorage.setItem('access_token', value);
    }

    clear() {
      localStorage.removeItem('openai_api_key');
      localStorage.removeItem('access_token');
    }
  }

  class Polymath {
    async ask(query) {
      const form = new FormData();
      form.append('version', '0');
      form.append('query_embedding_model', 'openai.com:text-embedding-ada-002');
      form.append('sort', 'similarity');
      for (const [key, value] of Object.entries(query)) {
        form.append(key, value);
      }
      const url = new URL(window.location);
      const result = await (await fetch(url, {
        method: 'POST',
        body: form
      })).json();
      return result;
    }

    static encode_embedding(data) {
      return btoa(String.fromCharCode(...(new Uint8Array(new Float32Array(data).buffer))));
    }

    static create_prompt({ query, results }) {
      const context = Object.values(results.content).map(chunk => chunk.text).join('\n');
      return `Answer the question as truthfully as possible using the provided context, and if the answer is not contained within the text below, say \"I don't know.\"\n\nContext:\n${context} \n\nQuestion:\n${query}\n\nAnswer:`;
    }

    static async synthesizeAnswers({ key, query, access_token }) {
      const server = new Polymath();
      const openai = new OpenAI(key);
      const result = {
        error: null,
        infos: null,
        completion: null,
      }

      const embedding = await openai.embedding(query);
      if (embedding.error) {
        result.error = embedding.error;
        return result;
      }

      const query_embedding = Polymath.encode_embedding(embedding.result);
      access_token = access_token || ''
      const polymath_results = await server.ask({ query_embedding, access_token });
      if (polymath_results.error) {
        result.error = polymath_results.error;
        return result;
      }

      const context = Polymath.create_prompt({
        query: query,
        results: polymath_results,
      });
      const completion_result = await openai.completion(context);
      if (completion_result.error) {
        result.error = completion_result.error;
        return result;
      }
      result.infos = Object.values(polymath_results.content).map(entry => entry.info);
      result.completion = completion_result.result;
      return result;
    }
  }

  class OpenAI {
    constructor(key) {
      this._key = key;
    }

    async _call_api(type, payload, result_getter) {
      const url = `https://api.openai.com/v1/${type}`;
      const result = await (await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this._key}`,
        },
        body: JSON.stringify(payload)
      })).json();
      if (result.error)
        return {
          error: result.error.message
        }
      return {
        result: result_getter(result)
      };
    }

    async validate() {
      const url = `https://api.openai.com/v1/models`;
      const result = await (await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${this._key}`,
        }
      })).json();
      return !result.error;
    }

    async completion(prompt) {
      return await this._call_api('completions', {
        model: 'text-davinci-003',
        prompt: prompt,
        max_tokens: 1024,
        temperature: 0,
        top_p: 1,
        n: 1,
        stream: false,
        logprobs: null,
        stop: '\n'
      }, out => out.choices[0].text);
    }

    async embedding(query) {
      return await this._call_api('embeddings', {
        input: query,
        model: 'text-embedding-ada-002'
      }, out => out.data[0].embedding);
    }
  }

  class Views {
    constructor() {
      this._surface = document.querySelector('#surface');
    }

    hide(viewId) {
      const instance = document.getElementById(`${viewId}-view-instance`);
      if (instance)
        instance.hidden = true;
    }

    show(viewId, ...data) {
      const templateId = `${viewId}-view`;
      const instanceId = `${templateId}-instance`;
      let instance = document.getElementById(instanceId);
      if (instance) {
        instance.hidden = false;
        return;
      }

      const template = document.getElementById(templateId);
      const clone = template.content.cloneNode(true);
      let logicScript = clone.querySelector('script[arguments]');
      if (logicScript) {
        let args = logicScript.getAttribute('arguments').split(',');
        const logic = new Function(...args, logicScript.textContent);
        logicScript.remove();
        logic.call(clone, ...data);
      }

      instance = document.createElement('div');
      instance.appendChild(clone);
      instance.id = instanceId;
      this._surface.appendChild(instance);
    }

    clear() {
      this._surface.textContent = '';
    }
  }

  class Controller {
    constructor() {
      this.store = new Keystore();
      this.views = new Views();
      this.results = null;
      this.url = new URL(window.location);
    }

    async storeKey(key) {
      const openai = new OpenAI(key);
      if (!await openai.validate()) {
        this.results = {
          error: 'Invalid API key'
        };
        this.start();
        return;
      }
      this.store.openai_api_key = key;
      this.results = null;
      this.start();
    }

    askServer({ query, access_token }) {
      this.url.searchParams.set('query', query);
      if (access_token)
        this.store.access_token = access_token;
      window.location.assign(this.url);
    }

    clearKeys() {
      this.store.clear();
      this.start();
    }

    async start() {
      this.views.clear();
      if (!this.store.openai_api_key) {
        this.views.show('request-key', this);
      } else {
        const access_token = this.url.searchParams.get('secret');
        if (access_token) {
          this.store.access_token = access_token;
          this.url.searchParams.delete('secret');
          window.location.assign(this.url);
          return;
        }
        const query = this.url.searchParams.get('query');
        if (!query) {
          this.views.show('query', this, '');
          return;
        }
        this.views.show('loading', this);
        this.views.hide('query');
        const answers = await Polymath.synthesizeAnswers({
          query: query,
          key: this.store.openai_api_key,
          access_token: this.store.access_token,
        });
        this.views.hide('loading')
        this.views.show('query', this, query);
        if (answers.error) {
          this.views.show('error', answers.error);
        } else {
          this.views.show('results', answers.completion, answers.infos);
        }
      }
      if (this.results && this.results.error) {
        this.views.show('error', this.results.error);
      }
    }
  }

  const controller = new Controller();
  controller.start();
</script>