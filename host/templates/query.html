<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>{{ config.webclient.headername }} Polymath</title>
<link rel="stylesheet" href="static/mvp.css" />
<style type="text/css">
  header,
  main {
    padding: 1rem;
  }

  details {
    text-align: right;
    margin-top: -50px;
  }

  #query {
    padding: 1rem;
    margin-bottom: 0px;
    --border-radius: 1em;
  }

  #sources li {
    font-size: smaller;
  }

  #completion {
    margin-bottom: 2em;
  }

  #results {
    margin-block-start: 2em;
  }

  header {
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
  }

  #header-a {
    border-radius: 25% 10%;
    overflow: hidden;
  }

  #header-img {
    float: left;
  }

  #header-text {
    padding-left: 20px;
    margin-top: -50px;
    float: right;
    border-bottom: none;
  }

  #header-line {
    width: 100%;
    height: 1px;
    border-top: none;
  }

  #button-wand {
    border: none;
    background-color: transparent;
    padding: 0;
    margin: 0;
  }

  #button-wand img {
    float: right;
    overflow:hidden;
    border-radius:25%;
    margin: 0 0 0 10px;
    padding: 0px;
    border: none;
    background-color: transparent;
  }

</style>
<link rel="apple-touch-icon" sizes="180x180" href="static/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="static/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="static/favicon-16x16.png">
<link rel="shortcut icon" href="static/favicon.ico">
<link rel="manifest" href="static/site.webmanifest">

<header>
  <a href="/" id="header-a" title="E.T. Go. Home."><img src="static/polymath-logo-120x120.png" width="120" height="120" id="header-img" alt=""></a>
  <div id="header-text">
    <h1>{{ config.webclient.headername }} Polymath</h1>
    <div id="header-line">This is a <a href="https://github.com/dglazkov/polymath">polymath</a> endpoint.</div>
  </div>
</header>

<main id="surface"></main>
<footer>
  {% if config.restricted_message %}
  <p>This server has additional private content that requires an access token to access. {{ config.restricted_message }}</p>
  {% endif %}
  <p>
    Want your own Polymath? <a href="https://github.com/dglazkov/polymath#readme">Come get started!</a>
  </p>
</footer>

<!-- View templates -->
<template id="query-view">
  <div id="query-wrapper" style="display:flex">
    <input type="text" id="query" placeholder="{{ config.webclient.placeholder }}" style="float:left">
    <button id="button-wand">
      <img src="static/magic-wand-50x50.png" width="50" height="50">
  </button>
  </div>
  <button id="ask">Ask Me</button>

  <details>
    <summary id="more-options">More options</summary>
    <p>
      <label for="access_token">access_token (optional):</label>
      <input type="text" name="access_token" id="access_token">
    </p>
    <p>
      <button id="clear">Clear Key and Access Token</button>
    </p>
  </details>
  <script action="init" arguments="controller,query_value">
    const textInput = this.querySelector('#query');
    textInput.value = query_value;
    const access_token = this.querySelector('#access_token');
    const askButton = this.querySelector('#ask');
    const askServer = () => controller.askServer({
      query: textInput.value,
      access_token: access_token.value,
    });
    if (!query_value) {
      askButton.disabled = true;
    }
    textInput.addEventListener('keyup', (event) => {
      askButton.disabled = textInput.value.length < 3;
      if (event.keyCode != 13 || askButton.disabled) {
        return;
      }
      askServer();
    });
    askButton.addEventListener('click', askServer);
    this.querySelector('#clear').addEventListener('click',
      () => controller.clearKeys());

    {% if config.webclient.fun_queries %}
    let funQueries = {{ config.webclient.fun_queries | safe }};
    {% else %}
    let funQueries = ["What is a Polymath?", "What has been written about Generative AI?"];
    {% endif %}

    this.querySelector('#button-wand').addEventListener('click', () => {
      textInput.value = funQueries[Math.floor(Math.random() * funQueries.length)]
      askButton.disabled = false;
    });

  </script>
</template>

<template id="request-key-view">
  <p>
    <label>
      To query this server, enter your Open AI API key:
      <input name="key" type="text">
    </label>
    <button>Save Key</button>
  </p>
  <p>
    <em>Your Open AI API key is stored locally and only ever transmitted directly to openai.com</em>
  </p>
  <script action="init" arguments="controller">
    const button = this.querySelector('button');
    const input = this.querySelector('input');
    button.addEventListener('click', () => controller.storeKey(input.value));
  </script>
</template>

<template id="loading-view">
  <p>
  <div id="past"></div>
  <span id="current"></span><span id="ellipsis"></span>
  </p>
  <script action="show" arguments="onprogress">

    const ellipsis = this.querySelector('#ellipsis');
    const current = this.querySelector('#current');
    const past = this.querySelector('#past');
    let dots = 0;

    onprogress((status) => {
      const div = document.createElement('div');
      const currentStatus = current.textContent;
      if (currentStatus) {
        div.innerHTML = `${currentStatus} &#9989;`;
        past.append(div);
      }
      current.textContent = status;
    });

    this.loadingInterval = setInterval(() => {
      dots = (dots + 1) % 4;
      ellipsis.textContent = '.'.repeat(dots);
    }, 300);
  </script>
  <script action="hide">
    if (this.loadingInterval) clearInterval(this.loadingInterval);
  </script>
</template>

<template id="results-view">
  <h3 id="results">Results</h3>
  <div id="completion"></div>
  <h3>Sources</h3>
  <ul id="sources">
  </ul>
  <script action="show" arguments="completion,infos">
    function removeDuplicates(arr) {
      let seen = new Set();
      return arr.filter(item => {
        if (!seen.has(item.url)) {
          seen.add(item.url);
          return true;
        }
        return false;
      });
    }

    this.querySelector('#completion').textContent = completion;
    this.querySelector('#sources').innerHTML = removeDuplicates(infos).map(info => {
      let shortDescription = (info.description.length > 100) ? info.description.substring(0, 100) + "..." : info.description;
      let escapedTitle = (info.description || info.title).replace(/"/g, "\\\"");
      return `<li><a href="${info.url}" title="${escapedTitle}">${info.title || shortDescription || info.url}</a></li>`;
    }).join('\n');
  </script>
</template>

<template id="error-view">
  <h3>Error</h3>
  <div id="message"></div>
  <script action="show" arguments="error">
    const message = this.querySelector('#message');
    message.textContent = error;
  </script>
</template>

<script type="module">

  // Contains all UI-specific logic.
  class Controller {
    store;
    views;
    results;
    url;

    constructor() {
      this.store = new Keystore();
      this.views = new Views();
      this.results = null;
      this.url = new URL(window.location);
    }

    async storeKey(key) {
      const openai = new OpenAI(key);
      if (!await openai.validate()) {
        this.results = {
          error: 'Invalid API key'
        };
        this.start();
        return;
      }
      this.store.openai_api_key = key;
      this.results = null;
      this.start();
    }

    askServer({ query, access_token }) {
      this.url.searchParams.set('query', query);
      if (access_token)
        this.store.access_token = access_token;

      window.history.pushState({}, '', this.url);
      this.start();
    }

    clearKeys() {
      this.store.clear();
      this.start();
    }

    async start() {
      this.views.clear();
      if (!this.store.openai_api_key) {
        this.views.show('request-key', this);
      } else {
        const access_token = this.url.searchParams.get('secret');
        if (access_token) {
          this.store.access_token = access_token;
          this.url.searchParams.delete('secret');
          window.location.assign(this.url);
          return;
        }
        const query = this.url.searchParams.get('query');
        if (!query) {
          this.views.show('query', this, '');
          return;
        }
        const pipe = new Pipe();
        this.views.show('loading', pipe.out);
        this.views.hide('query');
        const answers = await Polymath.synthesizeAnswers({
          query: query,
          key: this.store.openai_api_key,
          access_token: this.store.access_token,
          progress: pipe.in
        });
        this.views.hide('loading');
        this.views.show('query', this, query);
        if (answers.error) {
          this.views.show('error', answers.error);
        } else {
          this.views.show('results', answers.completion, answers.infos);
        }
      }
      if (this.results && this.results.error) {
        this.views.show('error', this.results.error);
      }
    }
  }

  // Boring support classes.

  class Pipe {
    in;
    out;
    sink;
    constructor() {
      this.in = (message) => {
        this.sink(message);
      }
      this.out = (sink) => {
        this.sink = sink;
      }
    }
  }

  class Keystore {
    get openai_api_key() {
      return localStorage.getItem('openai_api_key');
    }

    set openai_api_key(value) {
      localStorage.setItem('openai_api_key', value);
    }

    get access_token() {
      return localStorage.getItem('access_token');
    }

    set access_token(value) {
      localStorage.setItem('access_token', value);
    }

    clear() {
      localStorage.removeItem('openai_api_key');
      localStorage.removeItem('access_token');
    }
  }

  class Polymath {
    async ask(query) {
      const form = new FormData();
      form.append('version', '1');
      form.append('query_embedding_model', 'openai.com:text-embedding-ada-002');
      form.append('sort', 'similarity');
      for (const [key, value] of Object.entries(query)) {
        form.append(key, value);
      }
      const url = new URL(window.location);
      const result = await (await fetch(url, {
        method: 'POST',
        body: form
      })).json();
      return result;
    }

    static encode_embedding(data) {
      return btoa(String.fromCharCode(...(new Uint8Array(new Float32Array(data).buffer))));
    }

    static create_prompt({ query, results }) {
      const context = Object.values(results.bits).map(chunk => chunk.text).join('\n');
      return `Answer the question as truthfully as possible using the provided context, and if don't have the answer, say in a friendly tone that this Polymath instance does not contain the answer and suggest looking for this information elsewhere.\n\nContext:\n${context} \n\nQuestion:\n${query}\n\nAnswer:`;
    }

    static async synthesizeAnswers({ key, query, access_token, progress }) {
      const server = new Polymath();
      const openai = new OpenAI(key);
      const result = {
        error: null,
        infos: null,
        completion: null,
      }

      progress('Creating embedding for the query');
      const embedding = await openai.embedding(query);
      if (embedding.error) {
        result.error = embedding.error;
        return result;
      }

      progress('Asking Polymath instance to generate context');
      const query_embedding = Polymath.encode_embedding(embedding.result);
      access_token = access_token || ''
      const polymath_results = await server.ask({ query_embedding, access_token });
      if (polymath_results.error) {
        result.error = polymath_results.error;
        return result;
      }

      progress('Creating completion from context')
      const context = Polymath.create_prompt({
        query: query,
        results: polymath_results,
      });
      const completion_result = await openai.completion(context);
      if (completion_result.error) {
        result.error = completion_result.error;
        return result;
      }
      result.infos = Object.values(polymath_results.bits).map(entry => entry.info);
      result.completion = completion_result.result;
      progress('');
      return result;
    }
  }

  class OpenAI {
    constructor(key) {
      this._key = key;
    }

    async _call_api(type, payload, result_getter) {
      const url = `https://api.openai.com/v1/${type}`;
      const result = await (await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this._key}`,
        },
        body: JSON.stringify(payload)
      })).json();
      if (result.error)
        return {
          error: result.error.message
        }
      return {
        result: result_getter(result)
      };
    }

    async validate() {
      const url = `https://api.openai.com/v1/models`;
      const result = await (await fetch(url, {
        method: 'GET',
        headers: {
          'Authorization': `Bearer ${this._key}`,
        }
      })).json();
      return !result.error;
    }

    async completion(prompt) {
      return await this._call_api('completions', {
        model: 'text-davinci-003',
        prompt: prompt,
        max_tokens: 1024,
        temperature: 0,
        top_p: 1,
        n: 1,
        stream: false,
        logprobs: null,
        stop: '\n'
      }, out => out.choices[0].text);
    }

    async embedding(query) {
      return await this._call_api('embeddings', {
        input: query,
        model: 'text-embedding-ada-002'
      }, out => out.data[0].embedding);
    }
  }

  class Views {
    constructor() {
      this._surface = document.querySelector('#surface');
    }

    _makeIds(viewId) {
      return {
        templateId: `${viewId}-view`,
        instanceId: `${viewId}-view-instance`,
      };
    }

    _runLogic(viewId, name, data) {
      const { templateId, instanceId } = this._makeIds(viewId);
      let instance = document.getElementById(instanceId);
      let template = document.getElementById(templateId);
      let script = template.content.querySelector(`script[action="${name}"]`);
      if (script) {
        const attr = script.getAttribute('arguments');
        const args = attr ? script.getAttribute('arguments').split(',') : [];
        const f = Function(...args, script.textContent);
        f.call(instance, ...data);
      }
      return null;
    }

    init(viewId, ...data) {
      const { templateId, instanceId } = this._makeIds(viewId);
      const template = document.getElementById(templateId);
      const clone = template.content.cloneNode(true);
      [...clone.querySelectorAll('script')].forEach(script => script.remove());
      const instance = document.createElement('div');
      instance.appendChild(clone);
      instance.id = instanceId;
      this._surface.appendChild(instance);

      this._runLogic(viewId, 'init', data);
    }

    show(viewId, ...data) {
      const { templateId, instanceId } = this._makeIds(viewId);
      let instance = document.getElementById(instanceId);
      if (instance) {
        instance.hidden = false;
      } else {
        this.init(viewId, ...data);
      }
      this._runLogic(viewId, 'show', data);
    }

    hide(viewId, ...data) {
      const instance = document.getElementById(`${viewId}-view-instance`);
      if (!instance) {
        return;
      }
      instance.hidden = true;
      this._runLogic(viewId, 'hide', data);
    }

    clear() {
      this._surface.textContent = '';
    }
  }

  const controller = new Controller();
  controller.start();

</script>